# import pandas as pd
# from sklearn.model_selection import train_test_split
# from sklearn.linear_model import LogisticRegression
# from sklearn.metrics import classification_report
# import joblib

# class AIModel:
#     def __init__(self, model_path='ai_model.pkl'):
#         self.model_path = model_path
#         self.model = None

#     def train(self, csv_path, feature_cols, target_col):
#         df = pd.read_csv(csv_path)
#         X = df[feature_cols]
#         y = df[target_col]
#         X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
#         self.model = LogisticRegression(max_iter=1000)
#         self.model.fit(X_train, y_train)
#         y_pred = self.model.predict(X_test)
#         print(classification_report(y_test, y_pred))
#         joblib.dump(self.model, self.model_path)
#         print(f"Model saved to {self.model_path}")

#     def load(self):
#         self.model = joblib.load(self.model_path)

#     def predict(self, features):
#         if self.model is None:
#             self.load()
#         return self.model.predict([features])[0]


# The file is al_model.py





# import pandas as pd
# from bot import MomentumBot

# if __name__ == "__main__":
#     # Path to your historical CSV file
#     csv_path = "your_data.csv"  # Change this to your actual file

#     # Initialize your bot
#     bot = MomentumBot()

#     # Run backtest
#     results = bot.backtest_from_csv(csv_path)

#     # Show results
#     print(results)
#     # Optionally, save to a new CSV
#     results.to_csv("backtest_results.csv", index=False)



# This is backtest.py.






# import pandas as pd
# import numpy as np
# import yfinance as yf
# from datetime import datetime

# class MomentumBot:

#     def calculate_stop_loss_take_profit(self, entry_price, trend, atr, risk_reward_ratio=2):
#         """Calculate stop-loss and take-profit levels based on ATR and trend direction."""
#         if atr is None or atr == 0:
#             return 0, 0
#         if trend == "UPTREND":
#             stop_loss = entry_price - atr
#             take_profit = entry_price + atr * risk_reward_ratio
#         elif trend == "DOWNTREND":
#             stop_loss = entry_price + atr
#             take_profit = entry_price - atr * risk_reward_ratio
#         else:
#             stop_loss = entry_price - atr
#             take_profit = entry_price + atr * risk_reward_ratio
#         return stop_loss, take_profit

#     def calculate_position_size(self, price, atr, risk_per_trade=0.02, risk_multiplier=2):
#         """Calculate position size based on volatility and account balance"""
#         if atr is None or atr == 0:
#             return 0
#         risk_amount = self.account_balance * risk_per_trade
#         stop_distance = atr * risk_multiplier
#         position_size = risk_amount / stop_distance
#         return position_size

#     def calculate_atr(self, high_prices, low_prices, close_prices, window=14):
#         """Calculate Average True Range (ATR)"""
#         import pandas as pd
#         if len(high_prices) < window + 1:
#             return None
#         high = pd.Series(high_prices)
#         low = pd.Series(low_prices)
#         close = pd.Series(close_prices)
#         tr1 = high - low
#         tr2 = abs(high - close.shift())
#         tr3 = abs(low - close.shift())
#         tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
#         atr = tr.rolling(window=window).mean()
#         return atr.iloc[-1] if not atr.empty else None
#     # Example method: Use API key for a broker request
#     def get_account_info(self):
#         """Example: Use the API key to make a broker API request (pseudo-code)."""
#         import requests
#         if not self.api_key:
#             raise ValueError("API key is not set. Please set BROKER_API_KEY env variable or pass api_key to the bot.")
#         # Example endpoint (replace with your broker's real endpoint)
#         url = "https://api.broker.com/v1/account"
#         headers = {"Authorization": f"Bearer {self.api_key}"}
#         # This is a placeholder request. Replace with your broker's actual API usage.
#         response = requests.get(url, headers=headers)
#         if response.status_code == 200:
#             return response.json()
#         else:
#             raise Exception(f"Broker API error: {response.status_code} {response.text}")
#     # --- Additional Technical Indicators ---
#     def calculate_rsi(self, prices, window=14):
#         """Calculate Relative Strength Index (RSI)"""
#         if len(prices) < window + 1:
#             return None
#         series = pd.Series(prices)
#         delta = series.diff()
#         gain = delta.where(delta > 0, 0.0)
#         loss = -delta.where(delta < 0, 0.0)
#         avg_gain = gain.rolling(window=window, min_periods=window).mean()
#         avg_loss = loss.rolling(window=window, min_periods=window).mean()
#         rs = avg_gain / avg_loss
#         rsi = 100 - (100 / (1 + rs))
#         return rsi.iloc[-1] if not rsi.empty else None

#     def calculate_macd(self, prices, fast=12, slow=26, signal=9):
#         """Calculate MACD and Signal Line"""
#         if len(prices) < slow + signal:
#             return None, None
#         series = pd.Series(prices)
#         ema_fast = series.ewm(span=fast, adjust=False).mean()
#         ema_slow = series.ewm(span=slow, adjust=False).mean()
#         macd = ema_fast - ema_slow
#         signal_line = macd.ewm(span=signal, adjust=False).mean()
#         return macd.iloc[-1], signal_line.iloc[-1]

#     def calculate_bollinger_bands(self, prices, window=20, num_std=2):
#         """Calculate Bollinger Bands"""
#         if len(prices) < window:
#             return None, None, None
#         series = pd.Series(prices)
#         sma = series.rolling(window=window).mean()
#         std = series.rolling(window=window).std()
#         upper_band = sma + (num_std * std)
#         lower_band = sma - (num_std * std)
#         return upper_band.iloc[-1], sma.iloc[-1], lower_band.iloc[-1]
#     def __init__(self, initial_balance=10000, api_key=None):
#         import os
#         self.account_balance = initial_balance
#         self.position_size = 0
#         self.stop_loss = 0
#         self.take_profit = 0
#         self.in_position = False
#         self.entry_price = 0
#         # API key management
#         self.api_key = api_key or os.environ.get('BROKER_API_KEY')

#     def set_api_key(self, api_key):
#         """Set or update the broker API key."""
#         self.api_key = api_key

#     # Basic price movement methods
#     def moving_up(self, prev_price, price):
#         return price > prev_price

#     def moving_down(self, prev_price, price):
#         return price < prev_price

#     # EMA Calculation
#     def calculate_ema(self, prices, window):
#         """Calculate Exponential Moving Average"""
#         if len(prices) < window:
#             return None
#         return pd.Series(prices).ewm(span=window, adjust=False).mean().iloc[-1]

#     # Stochastic Oscillator with EMA smoothing
#     def calculate_stochastic(self, high_prices, low_prices, close_prices, k_period=14, d_period=3):
#         """Calculate Stochastic Oscillator with EMA smoothing"""
#         if len(close_prices) < k_period + d_period:
#             return None, None
        
#         highs = pd.Series(high_prices)
#         lows = pd.Series(low_prices)
#         closes = pd.Series(close_prices)
        
#         # Calculate %K
#         lowest_low = lows.rolling(window=k_period).min()
#         highest_high = highs.rolling(window=k_period).max()
        
#         raw_k = ((closes - lowest_low) / (highest_high - lowest_low)) * 100
        
#         # Apply EMA smoothing to %K and %D
#         k_percent = raw_k.ewm(span=d_period, adjust=False).mean()
#         d_percent = k_percent.ewm(span=d_period, adjust=False).mean()
        
#         return k_percent.iloc[-1] if not k_percent.empty else None, d_percent.iloc[-1] if not d_percent.empty else None

#     def get_stochastic_signal(self, k, d, overbought=80, oversold=20):
#         """Generate signals from Stochastic Oscillator"""
#         if k is None or d is None:
#             return None, "NO_DATA"
        
#         if k < oversold and d < oversold:
#             return "BUY", "Stochastic oversold"
#         elif k > overbought and d > overbought:
#             return "SELL", "Stochastic overbought"
#         elif k > d:
#             return "BUY", "Stochastic bullish"
#         elif k < d:
#             return "SELL", "Stochastic bearish"
        
#         return None, "NO_SIGNAL"

#     # Awesome Oscillator with periods 1 and 34
#     def calculate_awesome_oscillator(self, high_prices, low_prices, fast_period=1, slow_period=34):
#         """Calculate Awesome Oscillator (AO)"""
#         if len(high_prices) < slow_period:
#             return None, None
        
#         # Calculate median price (High + Low) / 2
#         median_prices = [(high + low) / 2 for high, low in zip(high_prices, low_prices)]
        
#         # Calculate SMAs
#         sma_fast = pd.Series(median_prices).rolling(window=fast_period).mean()
#         sma_slow = pd.Series(median_prices).rolling(window=slow_period).mean()
        
#         # Calculate AO
#         ao = sma_fast - sma_slow
        
#         current_ao = ao.iloc[-1] if not ao.empty else None
#         prev_ao = ao.iloc[-2] if len(ao) > 1 else None
        
#         return current_ao, prev_ao

#     def get_ao_signal(self, current_ao, prev_ao):
#         """Generate signals based on Awesome Oscillator"""
#         if current_ao is None or prev_ao is None:
#             return None, "NO_DATA"
        
#         if prev_ao <= 0 and current_ao > 0:
#             return "BUY", "AO crossed above zero"
#         elif prev_ao >= 0 and current_ao < 0:
#             return "SELL", "AO crossed below zero"
        
#         return None, "NO_SIGNAL"

#     # EMA-based trend detection
#     def detect_trend_ema(self, ema_13, ema_20, ema_50, current_price):
#         """Determine trend strength based on EMA alignment"""
#         if any(ema is None for ema in [ema_13, ema_20, ema_50]):
#             return "NEUTRAL", 0
        
#         # EMA alignment conditions
#         bullish_alignment = ema_13 > ema_20 > ema_50 and current_price > ema_13
#         bearish_alignment = ema_13 < ema_20 < ema_50 and current_price < ema_13
        
#         if bullish_alignment:
#             return "UPTREND", 0.5
#         elif bearish_alignment:
#             return "DOWNTREND", 0.5
#         else:
#             return "NEUTRAL", 0

#     # Momentum strategy
#     def momentum_strategy(self, price_history, high_prices, low_prices, close_prices, volume_data=None):
#         """Momentum strategy using EMA, Stochastic, and Awesome Oscillator"""
        
#         if len(price_history) < 50:
#             return {
#                 'buy_signal': False,
#                 'sell_signal': False,
#                 'stoch_k': None,
#                 'stoch_d': None,
#                 'trend': "NEUTRAL",
#                 'position_size': 0,
#                 'stop_loss': 0,
#                 'take_profit': 0,
#                 'ao_current': None,
#                 'ao_signal': None,
#                 'signals': ["No consensus"],
#                 'ema_13': None,
#                 'ema_20': None,
#                 'ema_50': None
#             }

#         # --- 2 out of 3 consensus logic ---
#         ema_13 = self.calculate_ema(price_history, 13)
#         ema_20 = self.calculate_ema(price_history, 20)
#         ema_50 = self.calculate_ema(price_history, 50)
#         stoch_k, stoch_d = self.calculate_stochastic(high_prices, low_prices, close_prices)
#         stoch_signal, stoch_reason = self.get_stochastic_signal(stoch_k, stoch_d)
#         ao_current, ao_prev = self.calculate_awesome_oscillator(high_prices, low_prices, 1, 34)
#         ao_signal, ao_reason = self.get_ao_signal(ao_current, ao_prev)
#         current_price = price_history[-1]
#         trend, strength = self.detect_trend_ema(ema_13, ema_20, ema_50, current_price)

#         ema_buy = ema_13 is not None and ema_20 is not None and ema_50 is not None and (ema_13 > ema_20 > ema_50 and current_price > ema_13)
#         ema_sell = ema_13 is not None and ema_20 is not None and ema_50 is not None and (ema_13 < ema_20 < ema_50 and current_price < ema_13)
#         stoch_buy = stoch_signal == "BUY"
#         stoch_sell = stoch_signal == "SELL"
#         ao_buy = ao_signal == "BUY"
#         ao_sell = ao_signal == "SELL"

#         buy_votes = sum([ema_buy, stoch_buy, ao_buy])
#         sell_votes = sum([ema_sell, stoch_sell, ao_sell])

#         final_buy_signal = buy_votes >= 2
#         final_sell_signal = sell_votes >= 2

#         if final_buy_signal:
#             agreed = []
#             if ema_buy: agreed.append("EMA bullish alignment")
#             if stoch_buy: agreed.append("Stochastic BUY")
#             if ao_buy: agreed.append("AO BUY")
#             signals = ["BUY: " + ", ".join(agreed)]
#         elif final_sell_signal:
#             agreed = []
#             if ema_sell: agreed.append("EMA bearish alignment")
#             if stoch_sell: agreed.append("Stochastic SELL")
#             if ao_sell: agreed.append("AO SELL")
#             signals = ["SELL: " + ", ".join(agreed)]
#         else:
#             signals = ["No consensus"]

#         # Calculate position size and risk levels
#         position_size = 0
#         stop_loss = 0
#         take_profit = 0
#         atr = self.calculate_atr(high_prices, low_prices, close_prices)
#         if final_buy_signal or final_sell_signal:
#             position_size = self.calculate_position_size(current_price, atr)
#             stop_loss, take_profit = self.calculate_stop_loss_take_profit(current_price, trend, atr)

#         return {
#             'buy_signal': final_buy_signal,
#             'sell_signal': final_sell_signal,
#             'stoch_k': stoch_k,
#             'stoch_d': stoch_d,
#             'trend': trend,
#             'position_size': position_size,
#             'stop_loss': stop_loss,
#             'take_profit': take_profit,
#             'ao_current': ao_current,
#             'ao_signal': ao_signal,
#             'signals': signals,
#             'ema_13': ema_13,
#             'ema_20': ema_20,
#             'ema_50': ema_50
#         }

#     def check_exit_conditions(self, current_price):
#         """Check if we need to exit position due to stop-loss or take-profit"""
#         if not self.in_position:
#             return None
            
#         pnl = (current_price - self.entry_price) * self.position_size
        
#         if (self.entry_price > self.stop_loss and current_price <= self.stop_loss) or \
#            (self.entry_price < self.stop_loss and current_price >= self.stop_loss):
#             self.account_balance += self.position_size * current_price
#             self.in_position = False
#             result = f"ðŸ›‘ STOP-LOSS | P&L: ${pnl:.2f}"
#             self._reset_position()
#             return result
            
#         elif (self.entry_price < self.take_profit and current_price >= self.take_profit) or \
#              (self.entry_price > self.take_profit and current_price <= self.take_profit):
#             self.account_balance += self.position_size * current_price
#             self.in_position = False
#             result = f"ðŸŽ¯ TAKE-PROFIT | P&L: ${pnl:.2f}"
#             self._reset_position()
#             return result
            
#         return None

#     def _reset_position(self):
#         """Reset position parameters after exit"""
#         self.position_size = 0
#         self.stop_loss = 0
#         self.take_profit = 0
#         self.entry_price = 0

#     def execute_trade(self, signal_type, price, position_size, stop_loss, take_profit):
#         """
#         Executes a trade and updates account balance and position status.
#         """
#         if signal_type not in ["BUY", "SELL"]:
#             return "Invalid trade signal."

#         # Mark as in position and store trade details
#         self.in_position = True
#         self.last_trade = {
#             "type": signal_type,
#             "price": price,
#             "size": position_size,
#             "stop_loss": stop_loss,
#             "take_profit": take_profit
#         }
#         # Example: Deduct position value from balance (for demo purposes)
#         self.account_balance -= position_size * price
#         return f"{signal_type} trade executed at {price:.4f} (size: {position_size}, SL: {stop_loss}, TP: {take_profit})"


# This is bot.py.







# import yfinance as yf
# import time
# import pandas as pd

# def get_latest_data(symbol="EURUSD=X"):
#     """Fetch the latest OHLCV data of a symbol from Yahoo Finance."""
#     try:
#         ticker = yf.Ticker(symbol)
#         df = ticker.history(period="1d", interval="1m")
#         if not df.empty:
#             return {
#                 'price': df["Close"].iloc[-1],
#                 'high': df["High"].iloc[-1],
#                 'low': df["Low"].iloc[-1],
#                 'open': df["Open"].iloc[-1],
#                 'volume': df["Volume"].iloc[-1]
#             }
#     except:
#         pass
#     return None

# def get_historical_data(symbol="EURUSD=X", period="1d", interval="1m"):
#     """Fetch historical OHLCV data for indicator calculations."""
#     try:
#         ticker = yf.Ticker(symbol)
#         df = ticker.history(period=period, interval=interval)
#         if not df.empty:
#             return {
#                 'prices': df["Close"].tolist(),
#                 'highs': df["High"].tolist(),
#                 'lows': df["Low"].tolist(),
#                 'opens': df["Open"].tolist(),
#                 'volumes': df["Volume"].tolist()
#             }
#     except:
#         pass
#     return {'prices': [], 'highs': [], 'lows': [], 'opens': [], 'volumes': []}

# def stream_prices(symbol="EURUSD=X", interval=5):
#     """Stream live prices with full OHLCV data every `interval` seconds (generator)."""
#     prev_price = None
#     historical_data = get_historical_data(symbol, period="1d", interval="1m")
    
#     price_history = historical_data['prices']
#     high_history = historical_data['highs']
#     low_history = historical_data['lows']
#     volume_history = historical_data['volumes']
    
#     while True:
#         latest_data = get_latest_data(symbol)
#         if latest_data and latest_data['price']:
#             current_price = latest_data['price']
            
#             # Update history arrays
#             price_history.append(current_price)
#             high_history.append(latest_data['high'])
#             low_history.append(latest_data['low'])
#             volume_history.append(latest_data['volume'])
            
#             # Keep last 200 data points
#             if len(price_history) > 200:
#                 price_history = price_history[-200:]
#                 high_history = high_history[-200:]
#                 low_history = low_history[-200:]
#                 volume_history = volume_history[-200:]
            
#             yield prev_price, current_price, price_history, high_history, low_history, volume_history
#             prev_price = current_price
#         time.sleep(interval)


# this is data.py.






# import yfinance as yf
# import pandas as pd
# import numpy as np

# def calculate_indicators(df):
#     df['EMA_10'] = df['Close'].ewm(span=10, adjust=False).mean()
#     df['EMA_20'] = df['Close'].ewm(span=20, adjust=False).mean()
#     delta = df['Close'].diff()
#     gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
#     loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
#     rs = gain / loss
#     df['RSI'] = 100 - (100 / (1 + rs))
#     exp1 = df['Close'].ewm(span=12, adjust=False).mean()
#     exp2 = df['Close'].ewm(span=26, adjust=False).mean()
#     df['MACD'] = exp1 - exp2
#     df['MACD_signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
#     df['BB_MA'] = df['Close'].rolling(window=20).mean()
#     df['BB_std'] = df['Close'].rolling(window=20).std()
#     df['BB_upper'] = df['BB_MA'] + 2 * df['BB_std']
#     df['BB_lower'] = df['BB_MA'] - 2 * df['BB_std']
#     return df

# def generate_signals(df):
#     # Simple rule: Buy if Close > EMA_10 and RSI < 30, Sell if Close < EMA_10 and RSI > 70
#     df['signal'] = 0
#     df.loc[(df['Close'] > df['EMA_10']) & (df['RSI'] < 30), 'signal'] = 1  # Buy
#     df.loc[(df['Close'] < df['EMA_10']) & (df['RSI'] > 70), 'signal'] = -1 # Sell
#     return df

# def main():
#     ticker = 'AAPL'
#     df = yf.download(ticker, period='1y', interval='1d')
#     df = df.reset_index()
#     # Flatten MultiIndex columns if present
#     if isinstance(df.columns, pd.MultiIndex):
#         df.columns = ['_'.join([str(i) for i in col if i]) for col in df.columns.values]
#     print('Columns after flattening:', df.columns.tolist())
#     # Try to use 'Close' or 'Close_AAPL' depending on column names
#     close_col = 'Close' if 'Close' in df.columns else None
#     for col in df.columns:
#         if col.lower().startswith('close'):
#             close_col = col
#             break
#     if not close_col:
#         raise ValueError("No 'Close' column found. Columns: " + str(df.columns.tolist()))
#     df = df.rename(columns={close_col: 'Close'})
#     df = calculate_indicators(df)
#     df = generate_signals(df)
#     df = df.dropna()
#     df.to_csv('your_data.csv', index=False)
#     print('Sample data with indicators and signals saved to your_data.csv')

# if __name__ == '__main__':
#     main()





# this is generate_sample_data.py.






# from bot import MomentumBot
# from data import stream_prices

# # Initialize bot
# bot = MomentumBot(initial_balance=10000)

# print("ðŸ”„ Starting MOMENTUM STRATEGY Bot (EMA 13/20/50 + Stochastic + AO)...")
# print(f"ðŸ’° Account Balance: ${bot.account_balance:,.2f}")
# print("â³ (Ctrl+C to stop)\n")

# for (prev_price, price, price_history, 
#      high_history, low_history, volume_history) in stream_prices("EURUSD=X", interval=10):
    
#     if prev_price is None:
#         continue

#     # Check exit conditions
#     exit_message = bot.check_exit_conditions(price)
#     if exit_message:
#         print(f"ðŸ”” {exit_message} | Balance: ${bot.account_balance:,.2f}")

#     # Run momentum strategy
#     result = bot.momentum_strategy(
#         price_history=price_history,
#         high_prices=high_history,
#         low_prices=low_history,
#         close_prices=price_history,
#         volume_data=volume_history
#     )
#     if not result or not isinstance(result, dict):
#         continue

#     if result['ema_13'] is not None and result['stoch_k'] is not None:
#         # Debug: Print indicator values and consensus logic
#         print(f"[DEBUG] EMA13: {result['ema_13']}, EMA20: {result['ema_20']}, EMA50: {result['ema_50']}")
#         print(f"[DEBUG] Stoch K: {result['stoch_k']}, Stoch D: {result['stoch_d']}, AO: {result['ao_current']}, AO Signal: {result['ao_signal']}")
#         print(f"[DEBUG] Buy consensus: {result['buy_signal']}, Sell consensus: {result['sell_signal']}")
#         # Display indicators
#         print(f"ðŸ“Š EMA13: {result['ema_13']:.4f} | EMA20: {result['ema_20']:.4f} | EMA50: {result['ema_50']:.4f}")
#         print(f"ðŸŽ¯ Stochastic: K={result['stoch_k']:.1f} | D={result['stoch_d']:.1f}")
        
#         # Awesome Oscillator display
#         ao_arrow = "ðŸŸ¢" if result['ao_current'] and result['ao_current'] > 0 else "ðŸ”´" if result['ao_current'] and result['ao_current'] < 0 else "âšª"
#         ao_shape = "â¬†ï¸" if result['ao_signal'] == 'BUY' else "â¬‡ï¸" if result['ao_signal'] == 'SELL' else "âž¡ï¸"
#         print(f"ðŸš€ Awesome Oscillator: {ao_arrow}{ao_shape} {result['ao_current']:.4f}" if result['ao_current'] else f"ðŸš€ Awesome Oscillator: {ao_arrow}{ao_shape} N/A")
        
#         print(f"ðŸ“ˆ Trend: {result['trend']}")
        
#         # Show signals
#         if result['signals']:
#             print(f"ðŸ“¢ Signals: {', '.join(result['signals'])}")
        
#         # Execute trades
#         if result['buy_signal'] and not bot.in_position:
#             trade_msg = bot.execute_trade("BUY", price, result['position_size'], result['stop_loss'], result['take_profit'])
#             if trade_msg:
#                 print(f"ðŸŽ¯ {trade_msg}")
#                 print(f"ðŸ’° Remaining Balance: ${bot.account_balance:,.2f}")
            
#         elif result['sell_signal'] and not bot.in_position:
#             trade_msg = bot.execute_trade("SELL", price, result['position_size'], result['stop_loss'], result['take_profit'])
#             if trade_msg:
#                 print(f"ðŸŽ¯ {trade_msg}")
#                 print(f"ðŸ’° Remaining Balance: ${bot.account_balance:,.2f}")

#     print("-" * 80)



# This is main.py.





# import pandas as pd
# from bot import MomentumBot
# from ai_model import AIModel


# class MomentumBotWithAI(MomentumBot):
#     def __init__(self, initial_balance=10000, ai_model_path="ai_model.pkl"):
#         super().__init__(initial_balance=initial_balance)
#         self.ai = AIModel(model_path=ai_model_path)
#         try:
#             self.ai.load()
#             print(f"ðŸ¤– AI model loaded from {ai_model_path}")
#         except Exception as e:
#             print(f"âš ï¸ Could not load AI model: {e}")

#     def momentum_strategy_with_ai(self, price_history, high_prices, low_prices, close_prices, volume_data=None):
#         """
#         Extend momentum strategy by combining technical consensus with AI prediction.
#         """
#         # Step 1: Run the original momentum strategy
#         base_result = super().momentum_strategy(price_history, high_prices, low_prices, close_prices, volume_data)

#         if not base_result or not isinstance(base_result, dict):
#             return base_result

#         # Step 2: Prepare AI features (example using indicators from result)
#         features = [
#             base_result["ema_13"] or 0,
#             base_result["ema_20"] or 0,
#             base_result["ema_50"] or 0,
#             base_result["stoch_k"] or 0,
#             base_result["stoch_d"] or 0,
#             base_result["ao_current"] or 0
#         ]

#         # Step 3: AI prediction (1 = BUY, -1 = SELL, 0 = HOLD)
#         try:
#             ai_signal = self.ai.predict(features)
#         except Exception as e:
#             print(f"âš ï¸ AI prediction failed: {e}")
#             ai_signal = 0

#         # Step 4: Combine signals
#         final_buy = base_result["buy_signal"] or (ai_signal == 1)
#         final_sell = base_result["sell_signal"] or (ai_signal == -1)

#         # Step 5: Add AI decision to the result
#         base_result["ai_signal"] = ai_signal
#         base_result["final_buy_signal"] = final_buy
#         base_result["final_sell_signal"] = final_sell

#         if ai_signal == 1:
#             base_result["signals"].append("AI: BUY")
#         elif ai_signal == -1:
#             base_result["signals"].append("AI: SELL")
#         else:
#             base_result["signals"].append("AI: HOLD")

#         return base_result


# # Example usage
# if __name__ == "__main__":
#     bot = MomentumBotWithAI(initial_balance=10000)

#     # Load CSV created by data.py
#     df = pd.read_csv("your_data.csv")
#     prices = df["Close"].tolist()
#     highs = df["High"].tolist() if "High" in df.columns else prices
#     lows = df["Low"].tolist() if "Low" in df.columns else prices

#     result = bot.momentum_strategy_with_ai(
#         price_history=prices[-60:],  # last 60 candles
#         high_prices=highs[-60:],
#         low_prices=lows[-60:],
#         close_prices=prices[-60:]
#     )

#     print("ðŸ“Š Final Strategy Output with AI:")
#     print(result)






# this is momentum_bot_with_al.py.


# i ONLY WHAT to add the EMA of 13 and 20  to have a reveals, trend and breakout. 



# can you make a justment with this requirement.




# 1.Risk management:
# >Position sizing based on  account balance.

# >Stop-loss and take-profit logic.

# >Maximum daily loss or trade limits.

# 2More indicators:

# >Add RSI, MACD, Bollinger band.

# >use multi-timframe analysis.

# 3.Signal filtering:

# >Require multiple indicators to align before entering a trade.

# >Add trend detections (only trade in the derection of the main trend).

# 4.Backtesting:

# >implement a backtesting module to test strategy on histrorical data.

# 5.Logging and analysis:

# >Log all trades,signal and indicator values for reviews.

# >Analysis win/loss ratio, draw down, and other performance metrics.

# 6.Real trading intergration.

# >Connect to a broker API for live trading(with paper trading mode for safety).

# 7.Notification system:

# >Send alert via email, telegram or other channels when signal accurs.

# 8.Parameter optimization:

# >Add a way to optimize indicator parameter automatically.




# and with AL i have the list that need you to do:



# 1.Feature engineering:
# >Use your existing technical indicators as features (input) for a machine learning models.

# 2.Model selection:

# >Start with simple models like logistic regresion, decision trees.

# >For more advanced strategies try neural network cusing libraries like sciki-learn,  Tensorflow or pytorcu.

# 3.Training:

# >Use your histrorical for prediction.

# 4.Intergration:

# >After training use, the models preditional as part of your signal generation logic in the bot.

# 5.THE LAST STEP:

# >Add(al_models.py) to handles training and predition with scikit-learn.

# >updates your bcaktesting or main script to use AL models for signal.



# can you add this in the code


# # 







print("----------------------------------------------------------------------------")




# ai_model.py

# Trains a Logistic Regression classifier on features/targets from CSV.

# Saves/loads model with joblib.

# Used later inside the bot to enhance momentum strategy.

# bot.py

# Streams live Yahoo Finance candles.

# Provides get_latest_data, get_historical_data, and stream_prices.

# backtest.py

# Defines MomentumBot with technical indicators (EMA, Stochastic, AO, ATR, Bollinger, RSI, MACD).

# Has a momentum strategy that uses 2-of-3 consensus from indicators.

# Includes trade execution, stop-loss/take-profit, position sizing.

# data.py

# Downloads data (default AAPL daily candles).

# Computes indicators (EMA, RSI, MACD, Bollinger).

# Generates a sample dataset with signal column.

# Saves to your_data.csv â†’ training/testing file for the AI.

# generate_sample_data.py

# Runs live streaming mode with MomentumBot.

# Prints indicator values, consensus signals, executes trades.

# main.py

# Defines MomentumBotWithAI, which extends MomentumBot.

# Adds AI predictions to technical strategy (AI signal = BUY/SELL/HOLD).

# Combines signals: final BUY/SELL if either consensus OR AI agrees.